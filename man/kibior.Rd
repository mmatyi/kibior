% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api.R, R/kibior.R
\docType{class}
\name{kibior}
\alias{kibior}
\alias{Kibior}
\title{KibioR, an Kibio and Elasticsearch data manaipulation package.}
\format{
\code{\link{R6Class}} object.
}
\description{
KibioR is a lightweight package for data manipulation 
 with Elasticsearch. Its main features allow easy data import, export,
 download, upload, searching and sharing to any Elasticsearch-based open 
 architecture, scaling to billions of data and TB capability.

Kibior is a Kibio/Elasticsearch client written with R6 class. 
Instances of Kibior are object that allow to use Elasticsearch power and execute lots of predefined 
requests such as searching in massive amounts of data, joins between in-memory data and Elasticsearch 
indices, push and pull data to and from multiples Elasticsearch servers, and more. This little 
utilitary was built in the context of massive data invading biology and bioinformatics, but is completely
versatile and can be applied to other fields. By adding it to R-scripts, it can perform several 
useful tasks such as: saving intermediary results, sharing them with a collaborator, automating 
import and upload of lots of files directly, and much more.
}
\details{
A client to send, retrieve, search, join data in Elasticsearch.
}
\section{Constructor}{
 
 Kibior$new(host = "localhost", port = 9200, user = NULL, pwd = NULL, verbose = FALSE)
}

\section{Constructor Arguments}{

 \tabular{llll}{
 \strong{Argument} \tab \strong{Type} \tab \strong{Details} \tab \strong{Default} \cr
 \code{host} \tab character \tab address or name of Elasticsearch server \tab "localhost" \cr
 \code{port} \tab numeric \tab port of Elasticsearch server \tab 9200 \cr
 \code{user} \tab character \tab if required by the server, the username for authentication \tab NULL \cr
 \code{pwd} \tab character \tab if required by the server, the password for authentication \tab NULL \cr
 \code{verbose} \tab logical \tab verbose mode \tab FALSE \cr
 }

 created
}

\examples{

## ------------------------------------------------
## Method `Kibior$new`
## ------------------------------------------------

# default initiatlization, connect to "localhost:9200"
kc <- Kibior$new()
# connect to "192.168.2.145:9200"
kc <- Kibior$new("192.168.2.145")
# connect to "es:15005", verbose mode activated
kc <- Kibior$new(host = "elasticsearch", port = 15005, verbose = TRUE)
# connect to "192.168.2.145:9450" with credentials "foo:bar"
kc <- Kibior$new(host = "192.168.2.145", port = 9450, 
 user = "foo", pwd = "bar")
# connect to "elasticsearch:9200"
kc <- Kibior$new("elasticsearch")

# preparing all examples (do not mind this)
kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
if(kc$has("aaa")) kc$delete("aaa")
if(kc$has("bbb")) kc$delete("bbb")
if(kc$has("ccc")) kc$delete("ccc")
if(kc$has("ddd")) kc$delete("ddd")
if(kc$has("sw")) kc$delete("sw")
if(kc$has("sw_naboo")) kc$delete("sw_naboo")
if(kc$has("sw_tatooine")) kc$delete("sw_tatooine")
if(kc$has("sw_alderaan")) kc$delete("sw_alderaan")
if(kc$has("sw_from_file")) kc$delete("sw_from_file")
if(kc$has("storms")) kc$delete("storms")
if(kc_one$has("sw")) kc_one$delete("sw")
if(kc_one$has("sw_new")) kc_one$delete("sw_new")
if(kc_two$has("sw")) kc_two$delete("sw")
if(kc_two$has("sw_new")) kc_two$delete("sw_new")


## ------------------------------------------------
## Method `Kibior$print`
## ------------------------------------------------

kc <- Kibior$new("elasticsearch")
print(kc)


## ------------------------------------------------
## Method `Kibior$eq`
## ------------------------------------------------

kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
kc_one$eq(kc_two)
kc_two$eq(kc_one)



## ------------------------------------------------
## Method `Kibior$ne`
## ------------------------------------------------

kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
kc_one$ne(kc_two)
kc_two$ne(kc_one)


## ------------------------------------------------
## Method `Kibior$create`
## ------------------------------------------------

kc$create("aaa")
kc$create(c("bbb", "ccc"))


## ------------------------------------------------
## Method `Kibior$list`
## ------------------------------------------------

kc$list()


## ------------------------------------------------
## Method `Kibior$has`
## ------------------------------------------------

kc$has("aaa")
kc$has(c("bbb", "ccc"))
kc$has(c("bbb", "ddd"))


## ------------------------------------------------
## Method `Kibior$delete`
## ------------------------------------------------

kc$delete("aaa")
kc$delete(c("bbb", "ccc"))


## ------------------------------------------------
## Method `Kibior$stats`
## ------------------------------------------------

kc$stats()


## ------------------------------------------------
## Method `Kibior$ping`
## ------------------------------------------------

kc$ping()


## ------------------------------------------------
## Method `Kibior$get_metadata`
## ------------------------------------------------

# push test data, without magrittr
kc$push(dplyr::starwars, "sw")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Naboo"), "sw_naboo")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Tatooine"), "sw_tatooine")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Alderaan"), "sw_alderaan")
# get_metadata
kc$get_metadata()
kc$get_metadata("sw")
kc$get_metadata(c("sw", "sw_naboo"))


## ------------------------------------------------
## Method `Kibior$get_mappings`
## ------------------------------------------------

kc$get_mappings()
kc$get_mappings("sw")
kc$get_mappings(c("sw", "sw_naboo"))


## ------------------------------------------------
## Method `Kibior$get_settings`
## ------------------------------------------------

kc$get_settings()
kc$get_settings("sw")
kc$get_settings(c("sw", "sw_tatooine"))


## ------------------------------------------------
## Method `Kibior$get_aliases`
## ------------------------------------------------

kc$get_aliases()
kc$get_aliases("sw")
kc$get_aliases(c("sw", "sw_alderaan"))


## ------------------------------------------------
## Method `Kibior$count`
## ------------------------------------------------

# Number of observations (nb of records) in "sw"
kc$count("sw")
# Number of observations in indices "sw_naboo" and "sw_tatooine"
kc$count(c("sw_naboo", "sw_tatooine"))
# Number of variables (nb of columns) in index "sw_naboo"
kc$count("sw_naboo", type = "variables")


## ------------------------------------------------
## Method `Kibior$dim`
## ------------------------------------------------

# Couple [<nb obs> <nb var>] in "sw"
kc$dim("sw")
# Couple [<nb obs> <nb var>] in indices "sw_naboo" and "sw_alderaan"
kc$dim(c("sw_naboo", "sw_alderaan"))


## ------------------------------------------------
## Method `Kibior$get_fields`
## ------------------------------------------------

kc$get_fields("sw")          # direct search
kc$get_fields("sw_*")        # pattern search


## ------------------------------------------------
## Method `Kibior$export`
## ------------------------------------------------

f = tempfile(fileext=".csv")
# export and overwrite last file with the same data from Elasticsearch
kc$export(data = "sw", filepath = f)
# export from in-memory data to a file
kc$export(data = dplyr::starwars, filepath = f, force = TRUE)


## ------------------------------------------------
## Method `Kibior$import`
## ------------------------------------------------

# import to in-memory variable (data)
data <- kc$import(filepath = f)
# import to Elasticsearch index ("sw_from_file") if not exists
data <- kc$import(filepath = f, import_mode = "remote", push_index = "sw_from_file")
# import to index by recreating it, then pull indexed data
data <- kc$import(filepath = f, import_mode = "remote", push_index = "sw_from_file", 
 push_mode = "recreate")


## ------------------------------------------------
## Method `Kibior$push`
## ------------------------------------------------

# erase the last push data by recreating the index and re-pushing data
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate")
# characters names are unique, can be used as ID
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate", id_col = "name")
# a bit more complicated: update some data of the dataset "starwars"
# 38 records on 87 filtered
some_new_data <- dplyr::filter(dplyr::starwars, height > 180)
# make them all "gender <- female"
some_new_data["gender"] <- "female"
# update that apply, based on cahracter names to match the right record
kc$push(some_new_data, "sw", mode = "update", id_col = "name")
# view result by querying
kc$pull("sw", query = "height:>180", fields = c("name", "gender"))


## ------------------------------------------------
## Method `Kibior$pull`
## ------------------------------------------------

# push some data sample
kc$push(dplyr::storms, "storms")
# get the whole "sw" index
kc$pull("sw")
# get the whole "sw" index with all metadata
kc$pull("sw", keep_metadata = TRUE)
# get only "name" and "status" fields of indices starting with "s"
# fields not found will be ignored
kc$pull("s*", fields = c("name", "status"))
# limit the size of the result to 3
kc$pull("storms", max_size = 3)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `fields` to select only columns that matter
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)", fields = 
 c("name", "hair_color", "homeworld"))


## ------------------------------------------------
## Method `Kibior$move`
## ------------------------------------------------

kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
kc_one$push(dplyr::starwars, "sw", mode = "recreate")
# move data from an index to another (change name, same instance)
r <- kc_one$move(from_index = "sw", to_index = "sw_new")
# copy data from an index to another (same instance)
r <- kc_one$move(from_index = "sw_new", to_index = "sw", copy = TRUE)
kc_one$pull(c("sw","sw_new"))
# copy data from an instance to another
r <- kc_two$move(from_instance = kc_one, from_index = "sw_new", to_index = "sw", copy = TRUE)
# list instances
kc_one$list() 
kc_two$list() 
kc_two$pull("sw")


## ------------------------------------------------
## Method `Kibior$copy`
## ------------------------------------------------

# copy data from one index to another (same instance)
r <- kc_one$copy(from_index = "sw", to_index = "sw2")
kc_one$pull(c("sw", "sw2"))
# copy data from an instance to another
r <- kc_two$copy(from_instance = kc_one, from_index = "sw2", to_index = "sw2", force = TRUE)
# list instances
kc_one$list() 
kc_two$list() 
kc_two$pull(c("sw2"))



## ------------------------------------------------
## Method `Kibior$search`
## ------------------------------------------------

# search "sw" index, head mode on
kc$search("sw")
# search "sw" index with all metadata, head mode on
kc$search("sw", keep_metadata = TRUE)
# get only "name" field of the head of indices starting with "s"
# if an index does not have the "name" field, it will be empty
kc$search("s*", fields = "name")
# limit the size of the result to 50 to the whole index
kc$search("storms", max_size = 50, head = FALSE)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `fields` to select only columns that matter
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)", fields = 
 c("name", "hair_color", "homeworld"))


## ------------------------------------------------
## Method `Kibior$inner_join`
## ------------------------------------------------

# some data for joins examples
kc$push(ggplot2::diamonds, "diamonds")
# prepare join datasets, only big the biggest diamonds are selected (9)
sup_carat <- dplyr::filter(ggplot2::diamonds, carat > 3.5)
r <- kc$push(sup_carat, "diamonds_superior")
# execute a inner_join with one index and one in-memory dataset
kc$inner_join(left_index = ggplot2::diamonds, right_index = "diamonds_superior")
# execute a inner_join with one index queried, and one in-memory dataset
kc$inner_join(left_index = ggplot2::diamonds, right_index = "diamonds", right_query 
 = "carat:>3.5")


## ------------------------------------------------
## Method `Kibior$full_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a full_join with one index and one in-memory dataset
kc$full_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a full_join with one index queried, and one in-memory dataset
kc$full_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")


## ------------------------------------------------
## Method `Kibior$left_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a left_join with one index and one in-memory dataset
kc$left_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a left_join with one index queried, and one in-memory dataset
kc$left_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")


## ------------------------------------------------
## Method `Kibior$right_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a right_join with one index and one in-memory dataset
kc$right_join(left_index = fair_cut, right_index = "sup_carat")
# execute a right_join with one index queried, and one in-memory dataset
kc$right_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")


## ------------------------------------------------
## Method `Kibior$semi_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a semi_join with one index and one in-memory dataset
kc$semi_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a semi_join with one index queried, and one in-memory dataset
kc$semi_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")


## ------------------------------------------------
## Method `Kibior$anti_join`
## ------------------------------------------------

# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a anti_join with one index and one in-memory dataset
kc$anti_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a anti_join with one index queried, and one in-memory dataset
kc$anti_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")

}
\references{
Kibio.science: \url{http://kibio.science}, \cr
 Elasticsearch documentation: 
 \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html}
}
\seealso{
\code{\link{kibior}}

\url{https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#time-units} 
 for time-units and \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax}
 for the Elasticsearch query string syntax.

: \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html}
 Elasticsearch reindex feature for more information.

: \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html}
 Elasticsearch reindex feature for more information.

\url{https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#time-units} 
 for time-units and \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html#query-string-syntax}
 for the Elasticsearch query string syntax.
}
\author{
Régis Ongaro-Carcy,
 \email{regis.ongaro-carcy2@crchudequebec.ulaval.ca}
}
\concept{cluster-wealth}
\concept{crud-index}
\concept{crud-metadata}
\concept{joins}
\concept{move-data}
\concept{move-data, search}
\concept{search}
\keyword{data}
\keyword{dataset}
\keyword{integration}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{verbose}}{verbose mode, prints out more informations during execution}

\item{\code{quiet_progress}}{progressbar quiet mode, remove progress bar, useful for cleaner 
tests}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{host}}{Access and change the Elasticsearch host}

\item{\code{port}}{Access and change the Elasticsearch port}

\item{\code{endpoint}}{Access the Elasticsearch main endpoint}

\item{\code{user}}{Access the Elasticsearch user.}

\item{\code{pwd}}{Access the Elasticsearch password.}

\item{\code{connection}}{Access the Elasticsearch connection object.}

\item{\code{head_search_size}}{Access and change the head size default value.}

\item{\code{cluster_name}}{Access the cluster name if and only if already connected.}

\item{\code{cluster_status}}{Access the cluster status if and only if already connected.}

\item{\code{nb_documents}}{Access the current cluster total number of documents if and only if 
already connected.}

\item{\code{version}}{Access the Elasticsearch version if and only if already connected.}

\item{\code{elastic_wait}}{Access and change the Elasticsearch wait time for update commands if 
and only if already connected.}

\item{\code{valid_joins}}{Access the valid joins available in Kibior.}

\item{\code{valid_count_types}}{Access the valid count types available (mainly observations = 
rows, variables = columns)}

\item{\code{valid_elastic_metadata_types}}{Access the valid Elasticsearch metadata types 
available.}

\item{\code{valid_push_modes}}{Access the valid push modes available.}

\item{\code{shard_number}}{Access and modify the number of allocated primary shards when 
creating an Elasticsearch index.}

\item{\code{shard_replicas_number}}{Access and modify the number of allocated replicas in an 
Elasticsearch index.}

\item{\code{default_id_col}}{Access and modify the default ID column/field created when pushing 
data to Elasticsearch.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Kibior$new()}}
\item \href{#method-print}{\code{Kibior$print()}}
\item \href{#method-eq}{\code{Kibior$eq()}}
\item \href{#method-ne}{\code{Kibior$ne()}}
\item \href{#method-create}{\code{Kibior$create()}}
\item \href{#method-list}{\code{Kibior$list()}}
\item \href{#method-has}{\code{Kibior$has()}}
\item \href{#method-delete}{\code{Kibior$delete()}}
\item \href{#method-stats}{\code{Kibior$stats()}}
\item \href{#method-ping}{\code{Kibior$ping()}}
\item \href{#method-get_metadata}{\code{Kibior$get_metadata()}}
\item \href{#method-get_mappings}{\code{Kibior$get_mappings()}}
\item \href{#method-get_settings}{\code{Kibior$get_settings()}}
\item \href{#method-get_aliases}{\code{Kibior$get_aliases()}}
\item \href{#method-count}{\code{Kibior$count()}}
\item \href{#method-dim}{\code{Kibior$dim()}}
\item \href{#method-get_fields}{\code{Kibior$get_fields()}}
\item \href{#method-export}{\code{Kibior$export()}}
\item \href{#method-import}{\code{Kibior$import()}}
\item \href{#method-push}{\code{Kibior$push()}}
\item \href{#method-pull}{\code{Kibior$pull()}}
\item \href{#method-move}{\code{Kibior$move()}}
\item \href{#method-copy}{\code{Kibior$copy()}}
\item \href{#method-search}{\code{Kibior$search()}}
\item \href{#method-inner_join}{\code{Kibior$inner_join()}}
\item \href{#method-full_join}{\code{Kibior$full_join()}}
\item \href{#method-left_join}{\code{Kibior$left_join()}}
\item \href{#method-right_join}{\code{Kibior$right_join()}}
\item \href{#method-semi_join}{\code{Kibior$semi_join()}}
\item \href{#method-anti_join}{\code{Kibior$anti_join()}}
\item \href{#method-clone}{\code{Kibior$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$new(
  host = "localhost",
  port = 9200,
  user = NULL,
  pwd = NULL,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{host}}{The target host to connect to Elasticsearch REST API (default: "localhost").}

\item{\code{port}}{The target port (default: 9200).}

\item{\code{user}}{If the server needs authentication, your username (default: NULL).}

\item{\code{pwd}}{If the server needs authentication, your password (default: NULL).}

\item{\code{verbose}}{The verbose mode (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Initialize a new object, automatically called when calling `Kibior$new()`
}

\subsection{Returns}{
a new instance/object of Kibior
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# default initiatlization, connect to "localhost:9200"
kc <- Kibior$new()
# connect to "192.168.2.145:9200"
kc <- Kibior$new("192.168.2.145")
# connect to "es:15005", verbose mode activated
kc <- Kibior$new(host = "elasticsearch", port = 15005, verbose = TRUE)
# connect to "192.168.2.145:9450" with credentials "foo:bar"
kc <- Kibior$new(host = "192.168.2.145", port = 9450, 
 user = "foo", pwd = "bar")
# connect to "elasticsearch:9200"
kc <- Kibior$new("elasticsearch")

# preparing all examples (do not mind this)
kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
if(kc$has("aaa")) kc$delete("aaa")
if(kc$has("bbb")) kc$delete("bbb")
if(kc$has("ccc")) kc$delete("ccc")
if(kc$has("ddd")) kc$delete("ddd")
if(kc$has("sw")) kc$delete("sw")
if(kc$has("sw_naboo")) kc$delete("sw_naboo")
if(kc$has("sw_tatooine")) kc$delete("sw_tatooine")
if(kc$has("sw_alderaan")) kc$delete("sw_alderaan")
if(kc$has("sw_from_file")) kc$delete("sw_from_file")
if(kc$has("storms")) kc$delete("storms")
if(kc_one$has("sw")) kc_one$delete("sw")
if(kc_one$has("sw_new")) kc_one$delete("sw_new")
if(kc_two$has("sw")) kc_two$delete("sw")
if(kc_two$has("sw_new")) kc_two$delete("sw_new")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$print()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Print simple informations of the current object.
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc <- Kibior$new("elasticsearch")
print(kc)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-eq"></a>}}
\if{latex}{\out{\hypertarget{method-eq}{}}}
\subsection{Method \code{eq()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$eq(other = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{other}}{Another instance/object of Kibior (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Tells if another instance of Kibior has the same `host:port` couple.
}

\subsection{Returns}{
TRUE if hosts and ports are identical, else FALSE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
kc_one$eq(kc_two)
kc_two$eq(kc_one)


}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ne"></a>}}
\if{latex}{\out{\hypertarget{method-ne}{}}}
\subsection{Method \code{ne()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$ne(other = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{other}}{Another instance/object of Kibior (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Tells if another instance of Kibior has a different `host:port` couple.
}

\subsection{Returns}{
TRUE if hosts and ports are differents, else FALSE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
kc_one$ne(kc_two)
kc_two$ne(kc_one)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create"></a>}}
\if{latex}{\out{\hypertarget{method-create}{}}}
\subsection{Method \code{create()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$create(index_name = NULL, force = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to create (default: NULL).}

\item{\code{force}}{Erase already existing identical index names? (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Create one or several indices in Elasticsearch.
}

\subsection{Returns}{
a list containing results of creation per index
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$create("aaa")
kc$create(c("bbb", "ccc"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-list"></a>}}
\if{latex}{\out{\hypertarget{method-list}{}}}
\subsection{Method \code{list()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$list()}\if{html}{\out{</div>}}
}

\subsection{Details}{
List indices in Elasticsearch.
}

\subsection{Returns}{
a list of index names, NULL if no index found
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$list()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-has"></a>}}
\if{latex}{\out{\hypertarget{method-has}{}}}
\subsection{Method \code{has()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$has(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to check (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Does Elasticsearch has one or several indices?
}

\subsection{Returns}{
TRUE if all given index names are present in Elasticsearch, else FALSE
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$has("aaa")
kc$has(c("bbb", "ccc"))
kc$has(c("bbb", "ddd"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-delete"></a>}}
\if{latex}{\out{\hypertarget{method-delete}{}}}
\subsection{Method \code{delete()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$delete(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to delete (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Delete one or several indices in Elasticsearch.
}

\subsection{Returns}{
a list containing results of deletion per index
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$delete("aaa")
kc$delete(c("bbb", "ccc"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-stats"></a>}}
\if{latex}{\out{\hypertarget{method-stats}{}}}
\subsection{Method \code{stats()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$stats()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Get stats about Elasticsearch cluster
}

\subsection{Returns}{
a list of statistics about the cluster
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$stats()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ping"></a>}}
\if{latex}{\out{\hypertarget{method-ping}{}}}
\subsection{Method \code{ping()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$ping()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Ping cluster connection
}

\subsection{Returns}{
the ping result with some basic infos
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$ping()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_metadata"></a>}}
\if{latex}{\out{\hypertarget{method-get_metadata}{}}}
\subsection{Method \code{get_metadata()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$get_metadata(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get metadata (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get metadata of indices
}

\subsection{Returns}{
the list of indices, each containing the 3 features (mappings,settings, aliases)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# push test data, without magrittr
kc$push(dplyr::starwars, "sw")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Naboo"), "sw_naboo")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Tatooine"), "sw_tatooine")
kc$push(dplyr::filter(dplyr::starwars, homeworld == "Alderaan"), "sw_alderaan")
# get_metadata
kc$get_metadata()
kc$get_metadata("sw")
kc$get_metadata(c("sw", "sw_naboo"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_mappings"></a>}}
\if{latex}{\out{\hypertarget{method-get_mappings}{}}}
\subsection{Method \code{get_mappings()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$get_mappings(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get mappings (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get mappings of indices
}

\subsection{Returns}{
the list of indices, containing their mapping
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$get_mappings()
kc$get_mappings("sw")
kc$get_mappings(c("sw", "sw_naboo"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_settings"></a>}}
\if{latex}{\out{\hypertarget{method-get_settings}{}}}
\subsection{Method \code{get_settings()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$get_settings(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get settings (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get settings of indices
}

\subsection{Returns}{
the list of indices, containing their settings
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$get_settings()
kc$get_settings("sw")
kc$get_settings(c("sw", "sw_tatooine"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_aliases"></a>}}
\if{latex}{\out{\hypertarget{method-get_aliases}{}}}
\subsection{Method \code{get_aliases()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$get_aliases(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get aliases (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get aliases of indices
}

\subsection{Returns}{
the list of indices, containing their aliases
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$get_aliases()
kc$get_aliases("sw")
kc$get_aliases(c("sw", "sw_alderaan"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-count"></a>}}
\if{latex}{\out{\hypertarget{method-count}{}}}
\subsection{Method \code{count()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$count(index_name = NULL, type = "observations")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get aliases (default: NULL).}

\item{\code{type}}{a string representing the type to count: "observations" or "variables" 
(default: "observations").}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Count observations or variables in Elasticsearch data
}

\subsection{Returns}{
the list of indices, containing their number of observations or variables. 
 Use `$dim()` for both
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# Number of observations (nb of records) in "sw"
kc$count("sw")
# Number of observations in indices "sw_naboo" and "sw_tatooine"
kc$count(c("sw_naboo", "sw_tatooine"))
# Number of variables (nb of columns) in index "sw_naboo"
kc$count("sw_naboo", type = "variables")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dim"></a>}}
\if{latex}{\out{\hypertarget{method-dim}{}}}
\subsection{Method \code{dim()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$dim(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names to get aliases (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Shortcut to `$count()` to match the classical `dim()` function pattern `[line col]`
}

\subsection{Returns}{
the list of indices, containing their number of observations and variables.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# Couple [<nb obs> <nb var>] in "sw"
kc$dim("sw")
# Couple [<nb obs> <nb var>] in indices "sw_naboo" and "sw_alderaan"
kc$dim(c("sw_naboo", "sw_alderaan"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_fields"></a>}}
\if{latex}{\out{\hypertarget{method-get_fields}{}}}
\subsection{Method \code{get_fields()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$get_fields(index_name = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{a vector of index names, can be a pattern (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Get fields (columns) of indices.
}

\subsection{Returns}{
a list of indices, each containing their fields.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc$get_fields("sw")          # direct search
kc$get_fields("sw_*")        # pattern search

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-export"></a>}}
\if{latex}{\out{\hypertarget{method-export}{}}}
\subsection{Method \code{export()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$export(data = NULL, filepath = NULL, force = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{an index name or in-memory data to be extracted to a file (default: NULL).}

\item{\code{filepath}}{the filepath to use as export, must contain the file extention (default: 
NULL).}

\item{\code{force}}{overwrite the file? (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Export data to a file.
Some data formats are not installed by default.
Use `rio::install_formats()` to be able to parse them.
}

\subsection{Returns}{
the filepath if correctly exported, else an error
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{f = tempfile(fileext=".csv")
# export and overwrite last file with the same data from Elasticsearch
kc$export(data = "sw", filepath = f)
# export from in-memory data to a file
kc$export(data = dplyr::starwars, filepath = f, force = TRUE)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-import"></a>}}
\if{latex}{\out{\hypertarget{method-import}{}}}
\subsection{Method \code{import()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$import(
  filepath = NULL,
  import_mode = "local",
  push_index = NULL,
  push_mode = "check",
  id_col = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filepath}}{the filepath to use as import, must contain the file extention (default: 
NULL).}

\item{\code{import_mode}}{can be "local" to get file data, "remote" to immediatly push them to 
Elasticsearch, "both" to push and pull. (default: "local").}

\item{\code{push_index}}{the name of the index where to push data (default: NULL).}

\item{\code{push_mode}}{the push mode (default: "check").}

\item{\code{id_col}}{the column name of unique IDs (default: NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Import data from file.
Some data formats are not installed by default.
Use `rio::install_formats()` to be able to parse them.
}

\subsection{Returns}{
data contained in the file as a tibble, or NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# import to in-memory variable (data)
data <- kc$import(filepath = f)
# import to Elasticsearch index ("sw_from_file") if not exists
data <- kc$import(filepath = f, import_mode = "remote", push_index = "sw_from_file")
# import to index by recreating it, then pull indexed data
data <- kc$import(filepath = f, import_mode = "remote", push_index = "sw_from_file", 
 push_mode = "recreate")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-push"></a>}}
\if{latex}{\out{\hypertarget{method-push}{}}}
\subsection{Method \code{push()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$push(
  data = NULL,
  index_name = NULL,
  bulk_size = 1000,
  mode = "check",
  id_col = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{the data to push (default: NULL).}

\item{\code{index_name}}{the index name to use in Elasticsearch (default: NULL).}

\item{\code{bulk_size}}{the number of record to send to Elasticsearch in a row (default: 1000).}

\item{\code{mode}}{the push mode, could be "check", "recreate" or "update" (default: "check").}

\item{\code{id_col}}{an column anme to use as ID, must be composed of unique elements (default: 
NULL).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Push data from in-memory to Elasticsearch.
Everything is done by bulk.
}

\subsection{Returns}{
the index_name given if the push ended well, else an error.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# erase the last push data by recreating the index and re-pushing data
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate")
# characters names are unique, can be used as ID
kc$push(dplyr::starwars, index_name = "sw", mode = "recreate", id_col = "name")
# a bit more complicated: update some data of the dataset "starwars"
# 38 records on 87 filtered
some_new_data <- dplyr::filter(dplyr::starwars, height > 180)
# make them all "gender <- female"
some_new_data["gender"] <- "female"
# update that apply, based on cahracter names to match the right record
kc$push(some_new_data, "sw", mode = "update", id_col = "name")
# view result by querying
kc$pull("sw", query = "height:>180", fields = c("name", "gender"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pull"></a>}}
\if{latex}{\out{\hypertarget{method-pull}{}}}
\subsection{Method \code{pull()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$pull(
  index_name = NULL,
  bulk_size = 1000,
  max_size = NULL,
  scroll_timer = "1m",
  keep_metadata = FALSE,
  fields = NULL,
  query = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{the index name to use in Elasticsearch (default: NULL).}

\item{\code{bulk_size}}{the number of record to send to Elasticsearch in a row (default: 1000).}

\item{\code{max_size}}{the number of record Elasticsearch will send (default: NULL (all data)).}

\item{\code{scroll_timer}}{the time the scroll API will let the request alive to scroll on the 
result (default: "1m" (1 minute)).}

\item{\code{keep_metadata}}{does Elasticsearch needs to sent metadata? Data fields will be 
prefixed by "_source." (default: FALSE).}

\item{\code{fields}}{a vector of fields to select (default: NULL (all fields)).}

\item{\code{query}}{a string formatted to Elasticsearch query syntax, see links for the syntax 
 details (default: NULL)

# Simple syntax details:}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Pull data from Elasticsearch.
Everything is done by bulk.
This method is essentially a wrapper around `$search()` with parameter `head = FALSE`
}

\subsection{Returns}{
a list of datasets corresponding to the pull request, else an error. Keys of the 
 list are index names matching the request, value are the associated tibbles
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# push some data sample
kc$push(dplyr::storms, "storms")
# get the whole "sw" index
kc$pull("sw")
# get the whole "sw" index with all metadata
kc$pull("sw", keep_metadata = TRUE)
# get only "name" and "status" fields of indices starting with "s"
# fields not found will be ignored
kc$pull("s*", fields = c("name", "status"))
# limit the size of the result to 3
kc$pull("storms", max_size = 3)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `fields` to select only columns that matter
r <- kc$pull("sw", query = "height:>180 && homeworld:(Tatooine || Naboo)", fields = 
 c("name", "hair_color", "homeworld"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-move"></a>}}
\if{latex}{\out{\hypertarget{method-move}{}}}
\subsection{Method \code{move()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$move(
  from_instance = NULL,
  from_index = NULL,
  to_index = NULL,
  force = FALSE,
  copy = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_instance}}{If not NULL, the Kibior object of another instance. if NULL 
(default), this instance will be used. (default: NULL).}

\item{\code{from_index}}{The source index name (default: NULL).}

\item{\code{to_index}}{The destination index name (default: NULL).}

\item{\code{force}}{Does the destination index need to be erase? (default: FALSE)}

\item{\code{copy}}{Does the destination have to be a copy of the source? FALSE (default) will 
delete source index, TRUE will keep it. (default: FALSE).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Move data from one index to another.
It needs to be configured in the `config/elasticsearch.yml` file to actually work.
}

\subsection{Returns}{
the reindex result
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{kc_one <- Kibior$new("elasticsearch", verbose = TRUE)
kc_two <- Kibior$new("elasticsearch2", verbose = TRUE)
kc_one$push(dplyr::starwars, "sw", mode = "recreate")
# move data from an index to another (change name, same instance)
r <- kc_one$move(from_index = "sw", to_index = "sw_new")
# copy data from an index to another (same instance)
r <- kc_one$move(from_index = "sw_new", to_index = "sw", copy = TRUE)
kc_one$pull(c("sw","sw_new"))
# copy data from an instance to another
r <- kc_two$move(from_instance = kc_one, from_index = "sw_new", to_index = "sw", copy = TRUE)
# list instances
kc_one$list() 
kc_two$list() 
kc_two$pull("sw")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-copy"></a>}}
\if{latex}{\out{\hypertarget{method-copy}{}}}
\subsection{Method \code{copy()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$copy(
  from_instance = NULL,
  from_index = NULL,
  to_index = NULL,
  force = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from_instance}}{If not NULL, the Kibior object of another instance. if NULL 
(default), this instance will be used. (default: NULL).}

\item{\code{from_index}}{The source index name (default: NULL).}

\item{\code{to_index}}{The destination index name (default: NULL).}

\item{\code{force}}{Does the destination index need to be erase? (default: FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Copy data from one index to another.
It needs to be configured in the `config/elasticsearch.yml` file to actually work.
This method is a wrapper around `$move(copy = TRUE)`.
}

\subsection{Returns}{
the reindex result
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# copy data from one index to another (same instance)
r <- kc_one$copy(from_index = "sw", to_index = "sw2")
kc_one$pull(c("sw", "sw2"))
# copy data from an instance to another
r <- kc_two$copy(from_instance = kc_one, from_index = "sw2", to_index = "sw2", force = TRUE)
# list instances
kc_one$list() 
kc_two$list() 
kc_two$pull(c("sw2"))


}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-search"></a>}}
\if{latex}{\out{\hypertarget{method-search}{}}}
\subsection{Method \code{search()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$search(
  index_name = "_all",
  keep_metadata = FALSE,
  fields = NULL,
  bulk_size = 1000,
  max_size = NULL,
  scroll_timer = "1m",
  head = TRUE,
  query = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{index_name}}{the index name to use in Elasticsearch (default: NULL).}

\item{\code{keep_metadata}}{does Elasticsearch needs to sent metadata? Data fields will be 
prefixed by "_source." (default: FALSE).}

\item{\code{fields}}{a vector of fields to select (default: NULL (all fields)).}

\item{\code{bulk_size}}{the number of record to send to Elasticsearch in a row (default: 1000).}

\item{\code{max_size}}{the number of record Elasticsearch will send (default: NULL (all data)).}

\item{\code{scroll_timer}}{the time the scroll API will let the request alive to scroll on the 
result (default: "1m" (1 minute)).}

\item{\code{head}}{a boolean limiting the search result and time (default: TRUE)}

\item{\code{query}}{a string formatted to Elasticsearch query syntax, see links for the syntax 
details (default: NULL)}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Search data from Elasticsearch.
The goal of this method is to discover quickly what data are interesting, thus 
 `head = TRUE` by default.
If you want to get all data, use `head = FALSE` or `$pull()`.
Everything is done by bulk.
}

\subsection{Returns}{
a list of datasets corresponding to the pull request, else an error. Keys of the 
 list are index names matching the request, value are the associated tibbles
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# search "sw" index, head mode on
kc$search("sw")
# search "sw" index with all metadata, head mode on
kc$search("sw", keep_metadata = TRUE)
# get only "name" field of the head of indices starting with "s"
# if an index does not have the "name" field, it will be empty
kc$search("s*", fields = "name")
# limit the size of the result to 50 to the whole index
kc$search("storms", max_size = 50, head = FALSE)
# use Elasticsearch query syntax to select and filter on all indices, for all data
# Here, we want to search for all records taht match the conditions:
# field "height" is strictly more than 180 AND field homeworld is "Tatooine" OR "Naboo"
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)")
# it can be used in conjunction with `fields` to select only columns that matter
kc$search("*", query = "height:>180 && homeworld:(Tatooine || Naboo)", fields = 
 c("name", "hair_color", "homeworld"))

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-inner_join"></a>}}
\if{latex}{\out{\hypertarget{method-inner_join}{}}}
\subsection{Method \code{inner_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$inner_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a inner join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("join_fields" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# some data for joins examples
kc$push(ggplot2::diamonds, "diamonds")
# prepare join datasets, only big the biggest diamonds are selected (9)
sup_carat <- dplyr::filter(ggplot2::diamonds, carat > 3.5)
r <- kc$push(sup_carat, "diamonds_superior")
# execute a inner_join with one index and one in-memory dataset
kc$inner_join(left_index = ggplot2::diamonds, right_index = "diamonds_superior")
# execute a inner_join with one index queried, and one in-memory dataset
kc$inner_join(left_index = ggplot2::diamonds, right_index = "diamonds", right_query 
 = "carat:>3.5")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-full_join"></a>}}
\if{latex}{\out{\hypertarget{method-full_join}{}}}
\subsection{Method \code{full_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$full_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a full join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("join_fields" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a full_join with one index and one in-memory dataset
kc$full_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a full_join with one index queried, and one in-memory dataset
kc$full_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-left_join"></a>}}
\if{latex}{\out{\hypertarget{method-left_join}{}}}
\subsection{Method \code{left_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$left_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a left join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("join_fields" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a left_join with one index and one in-memory dataset
kc$left_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a left_join with one index queried, and one in-memory dataset
kc$left_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-right_join"></a>}}
\if{latex}{\out{\hypertarget{method-right_join}{}}}
\subsection{Method \code{right_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$right_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a right join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("join_fields" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a right_join with one index and one in-memory dataset
kc$right_join(left_index = fair_cut, right_index = "sup_carat")
# execute a right_join with one index queried, and one in-memory dataset
kc$right_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-semi_join"></a>}}
\if{latex}{\out{\hypertarget{method-semi_join}{}}}
\subsection{Method \code{semi_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$semi_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a semi join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("join_fields" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a semi_join with one index and one in-memory dataset
kc$semi_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a semi_join with one index queried, and one in-memory dataset
kc$semi_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-anti_join"></a>}}
\if{latex}{\out{\hypertarget{method-anti_join}{}}}
\subsection{Method \code{anti_join()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$anti_join(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{see `join()` params.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Execute a anti join between two datasets using `dplyr` joins.
The datasets can be in-memory (variable name) or the name of an currently stored 
 Elasticsearch index. Joins cannot be done on column of type "list" ("join_fields" 
 argument).
}

\subsection{Returns}{
a tibble
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# prepare join datasets, fair cuts 
fair_cut <- dplyr::filter(ggplot2::diamonds, cut == "Fair")  # 1605 lines
sup_carat <- kc$pull("diamonds_superior")$diamonds_superior
# execute a anti_join with one index and one in-memory dataset
kc$anti_join(left_index = fair_cut, right_index = "diamonds_superior")
# execute a anti_join with one index queried, and one in-memory dataset
kc$anti_join(left_index = sup_carat, right_index = "diamonds", right_query 
 = "cut:fair")

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Kibior$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
